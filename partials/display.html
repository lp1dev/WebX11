<!DOCTYPE html>
<html>
<head>
    <title>WebTransport Client</title>
    <style>
        body {{ margin: 0; padding: 0; background: #000; overflow: hidden; }}
        .window {{ background: white; padding: 0; border-radius: 0; width: fit-content; }}
        .window-image {{ cursor: default; }}
        .connection-status {{
            position: fixed;
            top: 0px;
            right: 10px;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            font-family: sans-serif;
        }}
        .status-webtransport {{ background: #4CAF50; color: white; }}
        .status-websocket {{ background: #FF9800; color: white; }}
        .status-disconnected {{ background: #f44336; color: white; }}
        .fps-counter {{
            position: fixed;
            top: 30px;
            right: 10px;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            font-family: monospace;
            background: rgba(0, 0, 0, 0.7);
            color: #0f0;
            display: none;
        }}
    </style>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
</head>
<body>
    <div id="connectionStatus" class="connection-status status-disconnected">Connecting...</div>
    <div id="fpsCounter" class="fps-counter">FPS: 0.0</div>
    <div class="window">
        <img unselectable="on" style="user-select:none;" id="windowImage" class="window-image" src="" alt="Window" draggable="false">
    </div>
    
    <script>
        const debounce_timeout = 10;

        function debounce(func, timeout = debounce_timeout){{
            let timer;
            return (...args) => {{
                clearTimeout(timer);
                timer = setTimeout(() => {{ func.apply(this, args); }}, timeout);
            }};
        }}

        const windowId = {display_id};
        let transport = null;
        let ws = null;
        let datagramWriter = null;
        let useWebTransport = false;
        
        // Stats
        let stats = {{
            framesReceived: 0,
            lastFrameTime: Date.now(),
            fpsHistory: [],
            showFPS: false
        }};
        
        // FPS counter update
        function updateFPSCounter() {{
            if (!stats.showFPS) return;
            
            const now = Date.now();
            const oneSecondAgo = now - 1000;
            
            // Keep only frames from the last second
            stats.fpsHistory = stats.fpsHistory.filter(time => time > oneSecondAgo);
            
            const fps = stats.fpsHistory.length;
            const fpsEl = document.getElementById('fpsCounter');
            fpsEl.textContent = `FPS: ${{fps.toFixed(1)}}`;
        }}
        
        // Toggle FPS counter with F3
        document.addEventListener('keydown', (e) => {{
            if (e.key === 'F3') {{
                e.preventDefault();
                stats.showFPS = !stats.showFPS;
                const fpsEl = document.getElementById('fpsCounter');
                fpsEl.style.display = stats.showFPS ? 'block' : 'none';
                if (stats.showFPS) {{
                    stats.fpsHistory = [];
                }}
                return;
            }}
        }}, true); // Use capture phase to intercept before other handlers
        
        // Try WebTransport first, fallback to WebSocket
        async function connectWebTransport() {{
            if (!window.WebTransport) {{
                console.log('WebTransport not supported, falling back to WebSocket');
                await connectWebSocket();
                return;
            }}
            
            try {{
                const hostname = window.location.hostname || 'localhost';
                const wtUrl = `https://${{hostname}}:4433/wt/${{windowId}}`;
                let connected = false;
                transport = new WebTransport(wtUrl);

                setTimeout(() => {{
                    if (!connected) {{
                        console.log('Falling back to WebSocket');
                        connectWebSocket();
                        throw new Error('WebTransport:: TimeoutError');
                    }}
                }}, 2000);
                
                await transport.ready;
                connected = true;
                useWebTransport = true;
                updateStatus('webtransport');
                console.log('WebTransport connected');
                
                datagramWriter = transport.datagrams.writable.getWriter();
                
                // Handle incoming datagrams (control messages only)
                handleIncomingDatagrams();
                
                // Handle incoming streams (frame data)
                handleIncomingStreams();
                
                transport.closed.then(() => {{
                    console.log('WebTransport closed');
                    useWebTransport = false;
                    updateStatus('disconnected');
                }}).catch(err => {{
                    console.error('WebTransport error:', err);
                    useWebTransport = false;
                    updateStatus('disconnected');
                }});
                
            }} catch (error) {{
                console.error('WebTransport connection failed:', error);
            }}
        }}

        async function serverSync(settings) {{
            console.log('Settings :: ', window.settings)
            resize()
            clearInterval(window.setupInterval)
        }}

        const resize = debounce(() => {{
            if (window.settings.resize_mode == 'resize-x11') {{
                sendMessage({{
                    type: 'resize',
                    width: document.documentElement.clientWidth,
                    height: document.documentElement.clientHeight 
                }});
            }}
        }}, 100)

        async function handleIncomingDatagrams() {{
            try {{
                const reader = transport.datagrams.readable.getReader();
                console.log('Started listening for datagrams (control messages)...');
                
                while (true) {{
                    const {{ value, done }} = await reader.read();
                    
                    if (done) break;
                    
                    handleControlMessage(value);
                }}
            }} catch (error) {{
                console.error('Error reading datagrams:', error);
            }}
        }}

        async function handleIncomingStreams() {{
            try {{
                const reader = transport.incomingUnidirectionalStreams.getReader();
                console.log('Started listening for streams (frame data)...');
                
                while (true) {{
                    const {{ value: stream, done }} = await reader.read();
                    
                    if (done) break;
                    
                    // Handle each stream in parallel
                    handleFrameStream(stream);
                }}
            }} catch (error) {{
                console.error('Error reading streams:', error);
            }}
        }}

        async function handleFrameStream(stream) {{
            try {{
                const reader = stream.getReader();
                const chunks = [];
                let totalLength = 0;
                
                // Read all chunks from the stream
                while (true) {{
                    const {{ value, done }} = await reader.read();
                    
                    if (done) break;
                    
                    chunks.push(value);
                    totalLength += value.length;
                }}
                
                // Combine all chunks
                const fullData = new Uint8Array(totalLength);
                let offset = 0;
                for (const chunk of chunks) {{
                    fullData.set(chunk, offset);
                    offset += chunk.length;
                }}
                
                // Parse header (14 bytes)
                const view = new DataView(fullData.buffer, fullData.byteOffset, fullData.byteLength);
                const frameId = view.getUint16(0);
                const dataSize = view.getUint32(2);
                const timestamp = Number(view.getBigUint64(6));
                
                // Extract frame data
                const frameData = fullData.slice(14, 14 + dataSize);
                
                // Display frame
                displayFrame(frameData, frameId, timestamp);
                
            }} catch (error) {{
                console.error('Error handling frame stream:', error);
            }}
        }}
        
        function displayFrame(frameData, frameId, timestamp) {{
            try {{
                stats.framesReceived++;
                
                const now = Date.now();
                const latency = now - timestamp;
                const timeSinceLastFrame = now - stats.lastFrameTime;
                stats.lastFrameTime = now;
                
                // Add to FPS history
                stats.fpsHistory.push(now);
                updateFPSCounter();
                
                console.log(`Frame ${{frameId}}: ${{frameData.length}} bytes, latency: ${{latency}}ms, delta: ${{timeSinceLastFrame}}ms`);
                
                // Create blob and display
                const blob = new Blob([frameData], {{ type: 'image/webp' }});
                const imgUrl = URL.createObjectURL(blob);
                
                const img = document.getElementById('windowImage');
                if (img.src && img.src.startsWith('blob:')) {{
                    URL.revokeObjectURL(img.src);
                }}
                img.src = imgUrl;
                
            }} catch (error) {{
                console.error('Error displaying frame:', error);
            }}
        }}
        
        function handleControlMessage(data) {{
            try {{
                const message = JSON.parse(new TextDecoder().decode(data));
                console.log('Control message:', message);
            }} catch (e) {{
                console.error('Error parsing control message:', e);
            }}
        }}
        
        async function setup() {{
            const request = await fetch("/settings.json")
            let response = await request.json()
            window.settings = response.settings
            if (window.settings && window.settings.transport == 'webtransport') {{
                connectWebTransport()
            }} else {{
                console.log(window.settings, window.settings.transport)
                connectWebSocket()
            }}
        }}
        
        async function connectWebSocket() {{
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${{protocol}}//${{window.location.hostname}}:8081/ws/${{windowId}}`;
            let numFrames
            let lastDelta

            ws = new WebSocket(wsUrl);
            
            ws.onopen = () => {{
                useWebTransport = false;
                updateStatus('websocket');
                console.log('WebSocket connected');
                // Stats initialization
                numFrames = 0
                lastDelta = Date.now()
            }};
            
            ws.onmessage = (event) => {{
                let timer = Date.now()
                // It's an image blob 
                if (event.data instanceof Blob) {{
                    numFrames += 1

                    let windowImage = document.getElementById('windowImage')
                    if (windowImage.src && windowImage.src.startsWith('blob:')) {{
                        URL.revokeObjectURL(windowImage.src)
                    }}
                    windowImage.src = URL.createObjectURL(event.data)
                    stats.framesReceived++;
                    stats.fpsHistory.push(Date.now());
                    updateFPSCounter();
                    console.log(`===== frame ${{numFrames}} =====`)
                    console.log('clientdelta', (Date.now() - lastDelta) / 1000)
                    lastDelta = Date.now()
                }} else {{ // It's a JSON message
                    const data = JSON.parse(event.data);
                    if (data.settings) {{
                        serverSync(data.settings)
                    }}
                }}
            }};
            
            ws.onclose = () => {{
                updateStatus('reconnecting');
                setTimeout(connectWebSocket, 5000);
            }};
            
            ws.onerror = (error) => {{
                console.error('WebSocket error:', error);
            }};
        }}
        
        function updateStatus(status) {{
            const statusEl = document.getElementById('connectionStatus');
            statusEl.className = 'connection-status';
            
            switch(status) {{
                case 'webtransport':
                    statusEl.classList.add('status-webtransport');
                    statusEl.textContent = 'WebTransport (Streams)';
                    break;
                case 'websocket':
                    statusEl.classList.add('status-websocket');
                    statusEl.textContent = 'WebSocket';
                    break;
                case 'disconnected':
                    statusEl.classList.add('status-disconnected');
                    statusEl.textContent = 'Disconnected';
                    break;
                case 'reconnecting':
                    statusEl.classList.add('status-disconnected');
                    statusEl.textContent = 'Reconnecting';
                    break;
            }}
        }}
        
        async function sendMessage(message) {{
            if (useWebTransport && datagramWriter) {{
                try {{
                    const data = new TextEncoder().encode(JSON.stringify(message));
                    await datagramWriter.write(data);
                }} catch (error) {{
                    console.error('Error sending via WebTransport:', error);
                }}
            }} else if (ws && ws.readyState === WebSocket.OPEN) {{
                await ws.send(JSON.stringify(message));
            }}
        }}
        
        // Front-end event handling
        addEventListener("resize", resize)

        // Mouse and keyboard event handling
        const img = document.getElementById('windowImage');
        
        img.addEventListener('mousedown', (e) => {{
            const rect = e.target.getBoundingClientRect();
            const scaleX = e.target.naturalWidth / rect.width;
            const scaleY = e.target.naturalHeight / rect.height;
            const x = Math.round(e.offsetX * scaleX);
            const y = Math.round(e.offsetY * scaleY);
            
            sendMessage({{type: 'mousedown', x, y, button: 1}});
        }});

        img.addEventListener('mouseup', (e) => {{
            const rect = e.target.getBoundingClientRect();
            const scaleX = e.target.naturalWidth / rect.width;
            const scaleY = e.target.naturalHeight / rect.height;
            const x = Math.round(e.offsetX * scaleX);
            const y = Math.round(e.offsetY * scaleY);
            sendMessage({{type: 'mouseup', x, y, button: 1}});
        }});
        
        img.addEventListener('contextmenu', (e) => {{
            e.preventDefault();
            const rect = e.target.getBoundingClientRect();
            const scaleX = e.target.naturalWidth / rect.width;
            const scaleY = e.target.naturalHeight / rect.height;
            const x = Math.round(e.offsetX * scaleX);
            const y = Math.round(e.offsetY * scaleY);

            sendMessage({{type: 'mousedown', x, y, button: 3}});
        }});

        const onMouseMove = debounce((e) => {{
            const rect = e.target.getBoundingClientRect();
            const scaleX = e.target.naturalWidth / rect.width;
            const scaleY = e.target.naturalHeight / rect.height;
            const x = Math.round(e.offsetX * scaleX);
            const y = Math.round(e.offsetY * scaleY);
            sendMessage({{type: 'mousemove', x, y, button: 1}});
        }}, 50)

        img.addEventListener('mousemove', onMouseMove);
        
        img.addEventListener('wheel', (e) => {{
            const rect = e.target.getBoundingClientRect();
            const scaleX = e.target.naturalWidth / rect.width;
            const scaleY = e.target.naturalHeight / rect.height;
            const x = Math.round(e.offsetX * scaleX);
            const y = Math.round(e.offsetY * scaleY);
            
            sendMessage({{type: 'scroll', x, y, deltaY: e.deltaY}});
            e.preventDefault();
        }});
        
        document.addEventListener('keydown', (e) => {{
            if (e.key === 'F3') return; // Already handled above
            const key = getKeyFromEvent(e);
            if (key) {{
                sendMessage({{type: 'keydown', key}});
                e.preventDefault();
            }}
        }});
        
        document.addEventListener('keyup', (e) => {{
            if (e.key === 'F3') return; // Already handled above
            const key = getKeyFromEvent(e);
            if (key) {{
                sendMessage({{type: 'keyup', key}});
                e.preventDefault();
            }}
        }});
        
        function getKeyFromEvent(e) {{
            const specialKeys = {{
                'Escape': 'escape', 'Enter': 'enter', 'Tab': 'tab', 'Backspace': 'backspace',
                'Delete': 'delete', 'ArrowLeft': 'left', 'ArrowRight': 'right', 
                'ArrowUp': 'up', 'ArrowDown': 'down', 'Shift': 'shift', 'Control': 'control',
                'Alt': 'alt', 'Meta': 'super', ' ': 'space'
            }};
            
            if (specialKeys[e.key]) return specialKeys[e.key];
            if (e.key.match(/^F[1-9]$|^F1[0-2]$/)) return e.key.toLowerCase();
            if (e.key.length === 1) return e.key;
            return null;
        }}
        
        // Start connection
        setup()
        window.setupInterval = setInterval(() => {{
            serverSync()
        }}, 2000)

    </script>
</body>
</html>