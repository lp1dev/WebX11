<!DOCTYPE html>
<html>
<head>
    <title>WebTransport Client</title>
    <style>
        body {{ margin: 0; padding: 0; background: #000; overflow: hidden; }}
        .window {{ background: white; padding: 0; border-radius: 0; width: fit-content; }}
        .window-image {{ cursor: default; }}
        .connection-status {{
            position: fixed;
            top: 0px;
            right: 10px;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            font-family: sans-serif;
            display: none;
        }}
        .status-webtransport {{ background: #4CAF50; color: white; }}
        .status-websocket {{ background: #FF9800; color: white; }}
        .status-disconnected {{ background: #f44336; color: white; }}
        .fps-counter {{
            position: fixed;
            top: 30px;
            right: 10px;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            font-family: monospace;
            background: rgba(0, 0, 0, 0.7);
            color: #0f0;
            display: none;
        }}
        #hiddenInput {{
            position: absolute;
            left: -9999px;
            opacity: 0;
        }}
        .edge-scroll-indicator {{
            position: fixed;
            right: 0;
            top: 0;
            bottom: 0;
            width: 30px;
            background: rgba(255, 255, 255, 0.1);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }}
        .edge-scroll-indicator.active {{
            opacity: 1;
        }}
    </style>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
</head>
<body>
    <div id="connectionStatus" class="connection-status status-disconnected">Connecting...</div>
    <div id="fpsCounter" class="fps-counter">FPS: 0.0</div>
    <div id="edgeScrollIndicator" class="edge-scroll-indicator"></div>
    <input type="text" id="hiddenInput" autocomplete="off" />
    <div class="window">
        <img unselectable="on" style="user-select:none;" id="windowImage" class="window-image" src="" alt="Window" draggable="false">
    </div>
    
    <script>
        const debounce_timeout = 10;

        function debounce(func, timeout = debounce_timeout){{
            let timer;
            return (...args) => {{
                clearTimeout(timer);
                timer = setTimeout(() => {{ func.apply(this, args); }}, timeout);
            }};
        }}

        const windowId = {display_id};
        let transport = null;
        let ws = null;
        let datagramWriter = null;
        let useWebTransport = false;
        
        // Track composition state for dead keys
        let isComposing = false;
        let lastInputValue = '';
        
        // Touch gesture tracking
        let touchState = {{
            lastTapTime: 0,
            tapCount: 0,
            edgeScrollActive: false,
            edgeScrollStartY: 0,
            twoFingerScrollActive: false,
            lastTwoFingerY: 0,
            touches: new Map()
        }};
        
        // Stats
        let stats = {{
            framesReceived: 0,
            lastFrameTime: Date.now(),
            fpsHistory: [],
            showFPS: false
        }};
        
        // FPS counter update
        function updateFPSCounter() {{
            if (!stats.showFPS) return;
            
            const now = Date.now();
            const oneSecondAgo = now - 1000;
            
            // Keep only frames from the last second
            stats.fpsHistory = stats.fpsHistory.filter(time => time > oneSecondAgo);
            
            const fps = stats.fpsHistory.length;
            const fpsEl = document.getElementById('fpsCounter');
            fpsEl.textContent = `FPS: ${{fps.toFixed(1)}}`;
        }}
        
        // Toggle FPS counter with F3
        document.addEventListener('keydown', (e) => {{
            if (e.key === 'F3') {{
                e.preventDefault();
                stats.showFPS = !stats.showFPS;
                const fpsEl = document.getElementById('fpsCounter');
                const statusEl = document.getElementById('connectionStatus')
                fpsEl.style.display = stats.showFPS ? 'block' : 'none';
                statusEl.style.display = stats.showFPS ? 'block' : 'none'
                if (stats.showFPS) {{
                    stats.fpsHistory = [];
                }}
                return;
            }}
        }}, true); // Use capture phase to intercept before other handlers
        
        // Try WebTransport first, fallback to WebSocket
        async function connectWebTransport() {{
            if (!window.WebTransport) {{
                console.log('WebTransport not supported, falling back to WebSocket');
                await connectWebSocket();
                return;
            }}
            
            try {{
                const hostname = window.location.hostname || 'localhost';
                const wtUrl = `https://${{hostname}}:4433/wt/${{windowId}}`;
                let connected = false;
                transport = new WebTransport(wtUrl);

                setTimeout(() => {{
                    if (!connected) {{
                        console.log('Falling back to WebSocket');
                        connectWebSocket();
                        throw new Error('WebTransport:: TimeoutError');
                    }}
                }}, 2000);
                
                await transport.ready;
                connected = true;
                useWebTransport = true;
                updateStatus('webtransport');
                console.log('WebTransport connected');
                
                datagramWriter = transport.datagrams.writable.getWriter();
                
                // Handle incoming datagrams (control messages only)
                handleIncomingDatagrams();
                
                // Handle incoming streams (frame data)
                handleIncomingStreams();
                
                transport.closed.then(() => {{
                    console.log('WebTransport closed');
                    useWebTransport = false;
                    updateStatus('disconnected');
                }}).catch(err => {{
                    console.error('WebTransport error:', err);
                    useWebTransport = false;
                    updateStatus('disconnected');
                }});
                
            }} catch (error) {{
                console.error('WebTransport connection failed:', error);
            }}
        }}

        async function serverSync(settings) {{
            console.log('Settings :: ', window.settings)
            resize()
            clearInterval(window.setupInterval)
        }}

        const resize = debounce(() => {{
            if (window.settings.resize_mode == 'resize-x11') {{
                sendMessage({{
                    type: 'resize',
                    width: document.documentElement.clientWidth,
                    height: document.documentElement.clientHeight 
                }});
            }}
        }}, 100)

        async function handleIncomingDatagrams() {{
            try {{
                const reader = transport.datagrams.readable.getReader();
                console.log('Started listening for datagrams (control messages)...');
                
                while (true) {{
                    const {{ value, done }} = await reader.read();
                    
                    if (done) break;
                    
                    handleControlMessage(value);
                }}
            }} catch (error) {{
                console.error('Error reading datagrams:', error);
            }}
        }}

        async function handleIncomingStreams() {{
            try {{
                const reader = transport.incomingUnidirectionalStreams.getReader();
                console.log('Started listening for streams (frame data)...');
                
                while (true) {{
                    const {{ value: stream, done }} = await reader.read();
                    
                    if (done) break;
                    
                    // Handle each stream in parallel
                    handleFrameStream(stream);
                }}
            }} catch (error) {{
                console.error('Error reading streams:', error);
            }}
        }}

        async function handleFrameStream(stream) {{
            try {{
                const reader = stream.getReader();
                const chunks = [];
                let totalLength = 0;
                
                // Read all chunks from the stream
                while (true) {{
                    const {{ value, done }} = await reader.read();
                    
                    if (done) break;
                    
                    chunks.push(value);
                    totalLength += value.length;
                }}
                
                // Combine all chunks
                const fullData = new Uint8Array(totalLength);
                let offset = 0;
                for (const chunk of chunks) {{
                    fullData.set(chunk, offset);
                    offset += chunk.length;
                }}
                
                // Parse header (14 bytes)
                const view = new DataView(fullData.buffer, fullData.byteOffset, fullData.byteLength);
                const frameId = view.getUint16(0);
                const dataSize = view.getUint32(2);
                const timestamp = Number(view.getBigUint64(6));
                
                // Extract frame data
                const frameData = fullData.slice(14, 14 + dataSize);
                
                // Display frame
                displayFrame(frameData, frameId, timestamp);
                
            }} catch (error) {{
                console.error('Error handling frame stream:', error);
            }}
        }}
        
        function displayFrame(frameData, frameId, timestamp) {{
            try {{
                stats.framesReceived++;
                
                const now = Date.now();
                const latency = now - timestamp;
                const timeSinceLastFrame = now - stats.lastFrameTime;
                stats.lastFrameTime = now;
                
                // Add to FPS history
                stats.fpsHistory.push(now);
                updateFPSCounter();
                
                console.log(`Frame ${{frameId}}: ${{frameData.length}} bytes, latency: ${{latency}}ms, delta: ${{timeSinceLastFrame}}ms`);
                
                // Create blob and display
                const blob = new Blob([frameData], {{ type: 'image/webp' }});
                const imgUrl = URL.createObjectURL(blob);
                
                const img = document.getElementById('windowImage');
                if (img.src && img.src.startsWith('blob:')) {{
                    URL.revokeObjectURL(img.src);
                }}
                img.src = imgUrl;
                
            }} catch (error) {{
                console.error('Error displaying frame:', error);
            }}
        }}
        
        function handleControlMessage(data) {{
            try {{
                const message = JSON.parse(new TextDecoder().decode(data));
                console.log('Control message:', message);
            }} catch (e) {{
                console.error('Error parsing control message:', e);
            }}
        }}
        
        async function setup() {{
            const request = await fetch("/settings.json")
            let response = await request.json()
            window.settings = response.settings
            if (window.settings && window.settings.transport == 'webtransport') {{
                connectWebTransport()
            }} else {{
                console.log(window.settings, window.settings.transport)
                connectWebSocket()
            }}
        }}
        
        async function connectWebSocket() {{
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${{protocol}}//${{window.location.hostname}}:8081/ws/${{windowId}}`;
            let numFrames
            let lastDelta

            ws = new WebSocket(wsUrl);
            
            ws.onopen = () => {{
                useWebTransport = false;
                updateStatus('websocket');
                console.log('WebSocket connected');
                // Stats initialization
                numFrames = 0
                lastDelta = Date.now()
            }};
            
            ws.onmessage = (event) => {{
                let timer = Date.now()
                // It's an image blob 
                if (event.data instanceof Blob) {{
                    numFrames += 1

                    let windowImage = document.getElementById('windowImage')
                    if (windowImage.src && windowImage.src.startsWith('blob:')) {{
                        URL.revokeObjectURL(windowImage.src)
                    }}
                    windowImage.src = URL.createObjectURL(event.data)
                    stats.framesReceived++;
                    stats.fpsHistory.push(Date.now());
                    updateFPSCounter();
                    console.log(`===== frame ${{numFrames}} =====`)
                    console.log('clientdelta', (Date.now() - lastDelta) / 1000)
                    lastDelta = Date.now()
                }} else {{ // It's a JSON message
                    const data = JSON.parse(event.data);
                    if (data.settings) {{
                        serverSync(data.settings)
                    }}
                }}
            }};
            
            ws.onclose = () => {{
                updateStatus('reconnecting');
                setTimeout(connectWebSocket, 5000);
            }};
            
            ws.onerror = (error) => {{
                console.error('WebSocket error:', error);
            }};
        }}
        
        function updateStatus(status) {{
            const statusEl = document.getElementById('connectionStatus');
            statusEl.className = 'connection-status';
            
            switch(status) {{
                case 'webtransport':
                    statusEl.classList.add('status-webtransport');
                    statusEl.textContent = 'WebTransport (Streams)';
                    break;
                case 'websocket':
                    statusEl.classList.add('status-websocket');
                    statusEl.textContent = 'WebSocket';
                    break;
                case 'disconnected':
                    statusEl.classList.add('status-disconnected');
                    statusEl.textContent = 'Disconnected';
                    break;
                case 'reconnecting':
                    statusEl.classList.add('status-disconnected');
                    statusEl.textContent = 'Reconnecting';
                    break;
            }}
        }}
        
        async function sendMessage(message) {{
            if (useWebTransport && datagramWriter) {{
                try {{
                    const data = new TextEncoder().encode(JSON.stringify(message));
                    await datagramWriter.write(data);
                }} catch (error) {{
                    console.error('Error sending via WebTransport:', error);
                }}
            }} else if (ws && ws.readyState === WebSocket.OPEN) {{
                await ws.send(JSON.stringify(message));
            }}
        }}
        
        // Front-end event handling
        addEventListener("resize", resize)

        // Hidden input for capturing text with dead keys
        const hiddenInput = document.getElementById('hiddenInput');
        
        // Detect if device is mobile/tablet
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                         ('ontouchstart' in window);
        
        // Keep focus on hidden input to capture all text (desktop only or after double-tap on mobile)
        if (!isMobile) {{
            document.addEventListener('click', () => {{
                hiddenInput.focus();
            }});
            hiddenInput.focus();
        }}
        
        // Handle text input from hidden field
        hiddenInput.addEventListener('input', (e) => {{
            const newValue = hiddenInput.value;
            const addedText = newValue.substring(lastInputValue.length);
            
            if (addedText) {{
                console.log('Text input captured:', addedText);
                sendMessage({{type: 'text_input', text: addedText}});
            }}
            
            lastInputValue = newValue;
            
            // Clear input periodically to prevent it from getting too long
            if (newValue.length > 100) {{
                hiddenInput.value = '';
                lastInputValue = '';
            }}
        }});

        // Composition events
        hiddenInput.addEventListener('compositionstart', (e) => {{
            isComposing = true;
            console.log('Composition started');
        }});

        hiddenInput.addEventListener('compositionend', (e) => {{
            isComposing = false;
            console.log('Composition ended:', e.data);
        }});

        // Mouse and keyboard event handling
        const img = document.getElementById('windowImage');
        
        img.addEventListener('mousedown', (e) => {{
            const rect = e.target.getBoundingClientRect();
            const scaleX = e.target.naturalWidth / rect.width;
            const scaleY = e.target.naturalHeight / rect.height;
            const x = Math.round(e.offsetX * scaleX);
            const y = Math.round(e.offsetY * scaleY);
            
            sendMessage({{type: 'mousedown', x, y, button: 1}});
        }});

        img.addEventListener('mouseup', (e) => {{
            const rect = e.target.getBoundingClientRect();
            const scaleX = e.target.naturalWidth / rect.width;
            const scaleY = e.target.naturalHeight / rect.height;
            const x = Math.round(e.offsetX * scaleX);
            const y = Math.round(e.offsetY * scaleY);
            sendMessage({{type: 'mouseup', x, y, button: 1}});
        }});
        
        img.addEventListener('contextmenu', (e) => {{
            e.preventDefault();
            const rect = e.target.getBoundingClientRect();
            const scaleX = e.target.naturalWidth / rect.width;
            const scaleY = e.target.naturalHeight / rect.height;
            const x = Math.round(e.offsetX * scaleX);
            const y = Math.round(e.offsetY * scaleY);

            sendMessage({{type: 'mousedown', x, y, button: 3}});
        }});

        const onMouseMove = debounce((e) => {{
            const rect = e.target.getBoundingClientRect();
            const scaleX = e.target.naturalWidth / rect.width;
            const scaleY = e.target.naturalHeight / rect.height;
            const x = Math.round(e.offsetX * scaleX);
            const y = Math.round(e.offsetY * scaleY);
            sendMessage({{type: 'mousemove', x, y, button: 1}});
        }}, 50)

        img.addEventListener('mousemove', onMouseMove);
        
        img.addEventListener('wheel', (e) => {{
            const rect = e.target.getBoundingClientRect();
            const scaleX = e.target.naturalWidth / rect.width;
            const scaleY = e.target.naturalHeight / rect.height;
            const x = Math.round(e.offsetX * scaleX);
            const y = Math.round(e.offsetY * scaleY);
            
            sendMessage({{type: 'scroll', x, y, deltaY: e.deltaY}});
            e.preventDefault();
        }});
        
        // Touch event handlers for gestures
        img.addEventListener('touchstart', handleTouchStart, {{ passive: false }});
        img.addEventListener('touchmove', handleTouchMove, {{ passive: false }});
        img.addEventListener('touchend', handleTouchEnd, {{ passive: false }});
        img.addEventListener('touchcancel', handleTouchEnd, {{ passive: false }});
        
        function handleTouchStart(e) {{
            const touches = e.touches;
            const rect = e.target.getBoundingClientRect();
            const edgeThreshold = 30; // pixels from right edge
            
            // Update touch tracking
            for (let touch of touches) {{
                touchState.touches.set(touch.identifier, {{
                    x: touch.clientX,
                    y: touch.clientY,
                    startX: touch.clientX,
                    startY: touch.clientY
                }});
            }}
            
            // Check for double-tap (mobile keyboard activation)
            if (isMobile && touches.length === 1) {{
                const now = Date.now();
                const timeSinceLastTap = now - touchState.lastTapTime;
                
                if (timeSinceLastTap < 300) {{
                    // Double tap detected
                    touchState.tapCount = 2;
                    hiddenInput.focus();
                    console.log('Double-tap: keyboard activated');
                    e.preventDefault();
                    return;
                }} else {{
                    touchState.tapCount = 1;
                }}
                touchState.lastTapTime = now;
            }}
            
            // Check for edge scroll (single finger on right edge)
            if (touches.length === 1) {{
                const touch = touches[0];
                const distanceFromRightEdge = rect.right - touch.clientX;
                
                if (distanceFromRightEdge <= edgeThreshold) {{
                    touchState.edgeScrollActive = true;
                    touchState.edgeScrollStartY = touch.clientY;
                    document.getElementById('edgeScrollIndicator').classList.add('active');
                    e.preventDefault();
                    return;
                }}
            }}
            
            // Check for two-finger scroll
            if (touches.length === 2) {{
                touchState.twoFingerScrollActive = true;
                touchState.lastTwoFingerY = (touches[0].clientY + touches[1].clientY) / 2;
                e.preventDefault();
                return;
            }}
            
            // Regular mouse down for single touch (not on edge)
            if (touches.length === 1 && !touchState.edgeScrollActive) {{
                const touch = touches[0];
                const scaleX = e.target.naturalWidth / rect.width;
                const scaleY = e.target.naturalHeight / rect.height;
                const x = Math.round((touch.clientX - rect.left) * scaleX);
                const y = Math.round((touch.clientY - rect.top) * scaleY);
                
                sendMessage({{type: 'mousedown', x, y, button: 1}});
            }}
        }}
        
        function handleTouchMove(e) {{
            const touches = e.touches;
            const rect = e.target.getBoundingClientRect();
            
            // Handle edge scroll
            if (touchState.edgeScrollActive && touches.length === 1) {{
                const touch = touches[0];
                const deltaY = touch.clientY - touchState.edgeScrollStartY;
                const scaleX = e.target.naturalWidth / rect.width;
                const scaleY = e.target.naturalHeight / rect.height;
                const x = Math.round((touch.clientX - rect.left) * scaleX);
                const y = Math.round((touch.clientY - rect.top) * scaleY);
                
                // Send scroll message (converting touch delta to wheel delta)
                sendMessage({{type: 'scroll', x, y, deltaY: -deltaY * 2}});
                touchState.edgeScrollStartY = touch.clientY;
                e.preventDefault();
                return;
            }}
            
            // Handle two-finger scroll
            if (touchState.twoFingerScrollActive && touches.length === 2) {{
                const currentY = (touches[0].clientY + touches[1].clientY) / 2;
                const deltaY = currentY - touchState.lastTwoFingerY;
                
                const scaleX = e.target.naturalWidth / rect.width;
                const scaleY = e.target.naturalHeight / rect.height;
                const centerX = (touches[0].clientX + touches[1].clientX) / 2;
                const centerY = (touches[0].clientY + touches[1].clientY) / 2;
                const x = Math.round((centerX - rect.left) * scaleX);
                const y = Math.round((centerY - rect.top) * scaleY);
                
                // Send scroll message (converting touch delta to wheel delta)
                sendMessage({{type: 'scroll', x, y, deltaY: -deltaY * 2}});
                touchState.lastTwoFingerY = currentY;
                e.preventDefault();
                return;
            }}
            
            // Regular mouse move for single touch
            if (touches.length === 1 && !touchState.edgeScrollActive && !touchState.twoFingerScrollActive) {{
                const touch = touches[0];
                const scaleX = e.target.naturalWidth / rect.width;
                const scaleY = e.target.naturalHeight / rect.height;
                const x = Math.round((touch.clientX - rect.left) * scaleX);
                const y = Math.round((touch.clientY - rect.top) * scaleY);
                
                sendMessage({{type: 'mousemove', x, y, button: 1}});
            }}
        }}
        
        function handleTouchEnd(e) {{
            const touches = e.touches;
            const rect = e.target.getBoundingClientRect();
            
            // Clean up edge scroll
            if (touchState.edgeScrollActive) {{
                touchState.edgeScrollActive = false;
                document.getElementById('edgeScrollIndicator').classList.remove('active');
            }}
            
            // Clean up two-finger scroll
            if (touchState.twoFingerScrollActive && touches.length < 2) {{
                touchState.twoFingerScrollActive = false;
            }}
            
            // Update touch tracking
            const changedTouches = e.changedTouches;
            for (let touch of changedTouches) {{
                touchState.touches.delete(touch.identifier);
            }}
            
            // Send mouse up if all touches are gone
            if (touches.length === 0 && changedTouches.length > 0) {{
                const touch = changedTouches[0];
                const scaleX = e.target.naturalWidth / rect.width;
                const scaleY = e.target.naturalHeight / rect.height;
                const x = Math.round((touch.clientX - rect.left) * scaleX);
                const y = Math.round((touch.clientY - rect.top) * scaleY);
                
                sendMessage({{type: 'mouseup', x, y, button: 1}});
            }}
        }}
        
        // Only send special keys via key events, regular text via input event
        document.addEventListener('keydown', (e) => {{
            if (e.key === 'F3') return; // Already handled above
            
            const key = getKeyFromEvent(e);
            
            // Only send special keys (not regular text)
            if (key && !isRegularTextKey(e)) {{
                sendMessage({{type: 'keydown', key}});
                e.preventDefault();
            }}
        }});
        
        document.addEventListener('keyup', (e) => {{
            if (e.key === 'F3') return;
            
            const key = getKeyFromEvent(e);
            
            // Only send special keys (not regular text)
            if (key && !isRegularTextKey(e)) {{
                sendMessage({{type: 'keyup', key}});
                e.preventDefault();
            }}
        }});
        
        function isRegularTextKey(e) {{
            // Regular text keys should be handled by the input event
            // Special keys should be sent as key events
            return e.key.length === 1 && !e.ctrlKey && !e.altKey && !e.metaKey;
        }}
        
        function getKeyFromEvent(e) {{
            const specialKeys = {{
                'Escape': 'escape', 'Enter': 'enter', 'Tab': 'tab', 'Backspace': 'backspace',
                'Delete': 'delete', 'ArrowLeft': 'left', 'ArrowRight': 'right', 
                'ArrowUp': 'up', 'ArrowDown': 'down', 'Shift': 'shift', 'Control': 'control',
                'Alt': 'alt', 'Meta': 'super', ' ': 'space'
            }};
            
            if (specialKeys[e.key]) return specialKeys[e.key];
            if (e.key.match(/^F[1-9]$|^F1[0-2]$/)) return e.key.toLowerCase();
            if (e.key.length === 1) return e.key;
            return null;
        }}
        
        // Start connection
        setup()
        window.setupInterval = setInterval(() => {{
            serverSync()
        }}, 2000)

    </script>
</body>
</html>